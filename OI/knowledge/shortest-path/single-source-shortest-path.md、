### 单源最短路径

1. **Dijkstra**
   
   Dijkstra 算法用于求 **非负权图** 上单源最短路径的算法
   
   松弛操作：对于边$u$，$v$，松弛操作对应下面的式子
   
   $dis[v] = \min(dis[v],dis[u] + w[u,v]);$

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int N = 1e5+10;//结点MAX
const int M = 2e5 + 10;//边MAX
const int INF = 0x7fffffff;//正无穷
int head[N], tot;
//head[i]表示最后一个以i为起点的边的编号
int dis[N];
//dis[i]存储从起点st到第i个结点的最短路径的长度
bool vis[N];
//vis[i]表示是否求出了st->i的最短路
struct Edge {int to, next, w;}edge[M];
//边，to是终点，next表示和当前节点起点相同的上一条边
void add(int u, int v, int w)//加边，起点，终点，权值
{
    edge[++tot].to = v;
    edge[tot].w = w;
    edge[tot].next = head[u];
    head[u] = tot;//最后一条以u为起点的边的编号变为当前边
}

int main()
{
    priority_queue
    <pair<int,int>, vector<pair<int, int> >, greater<pair<int, int> > > Q;
    //建立小根堆存储dis，编号，确保每次取出dis最小的边
    int n, m, s;//点数，边数，开始点
    cin >> n >> m >> s;
    for (int i = 1; i <= m; ++i)
    {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w);
    }//建图

    for (int i = 1; i <= n; i++) 
        dis[i] = INF;//初始化为正无穷

    Q.push(make_pair(0, s)); dis[s] = 0;//初始化

    while (!Q.empty())
    {
        int t = Q.top().second; Q.pop();//取出队首元素编号
        if(vis[t]) continue;//如果该点的最短路已确定，跳过
        vis[t] = 1;
        for (int i = head[t]; i; i = edge[i].next)
        //遍历每一条以t为起点的边
        {
            int to = edge[i].to;//找到该边的终点
            if (dis[t] + edge[i].w < dis[to])
            //尝试对该边进行松弛操作
            {
                dis[to] = dis[t] + edge[i].w;
                Q.push(make_pair(dis[to], to));
            }
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << dis[i] << ' ';
    }

    return 0;
}
```

SPFA 算法

SPFA 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。

对于边 $(u,v)$，松弛操作对应下面的式子：$dis(v)=min(dis(v),dis(u)+w(u,v))$。

这么做的含义是显然的：我们尝试用 $s->u->v$（其中 $s->u$ 的路径取最短路）这条路径去更新 $v$ 点最短路的长度，如果这条路径更优，就进行更新。

$Bellman-Ford$ 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。

```c
bool Bellman-Ford (int n, int s) {
  memset(dis, 63, sizeof(dis));
  dis[s] = 0;
  bool flag;  // 判断一轮循环过程中是否发生松弛操作
  for (int i = 1; i <= n; i++) {
    flag = false;
    for (int u = 1; u <= n; u++) {
      if (dis[u] == inf) continue;
      // 无穷大与常数加减仍然为无穷大
      // 因此最短路长度为 inf 的点引出的边不可能发生松弛操作
      for (int i = head[u]; i; i = e[i].net) {
        int v = e[i].to, w = e[i].w;
        if (dis[v] > dis[u] + w) {
          dis[v] = dis[u] + w;
          flag = true;
        }
      }
    }
    // 没有可以松弛的边时就停止算法
    if (!flag) break;
  }
  // 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环
  return flag;
}
```

每次循环是 $O(m)$ 的，那么最多会循环多少次呢？

最短路存在的情况下，由于一次松弛操作会使最短路的边数至少 $+1$，而最短路的边数最多为 $n-1$，因此整个算法最多执行 $n-1$ 轮松弛操作。故总时间复杂度为 $O(nm)$

但还有一种情况，如果从 $s$ 点出发，抵达一个负环时，松弛操作会无休止地进行下去。注意到前面的论证中已经说明了，对于最短路存在的图，松弛操作最多只会执行 $n-1$ 轮，因此如果第 $n$ 轮循环时仍然存在能松弛的边，说明从 $s$ 点出发，能够抵达一个负环。

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。

## **SPFA 算法的实现步骤**

​实现 SPFA 算法需要一个队列 $q$，一个标记数组 $vis[N]$ 用来标记某点是否在队列中。数组 $dis[N]$，用来存储起点到某个点的最短距离。

- 初始化 $dis$ 数组为正无穷

- 从起点开始枚举每个点的所有子节点，设父节点到子节点的距离为 $s$，父节点到起点的距离为 $dist[u]$，子节点到起点的距离为$dist[v]$，如果 $dist[u]+s<dist[v]$ 当且仅当上式成立时就更新 $dist[v]$，如果 $v$ 没有在队列中，就将$v$入队。

```cpp
void spfa()
{
    queue<int> q;
    memset(dis,233333,sizeof(dis));
    q.push(n); dis[n] = 0; in[n] = 1;
    while(!q.empty())
    {
        int t = q.front(); q.pop(); in[t] = 0;
        for(int i = head[t]; i; i = e[i].net)
        {
            int to = e[i].to;
            if(dis[to] > dis[t] + e[i].w)
            {
                dis[to] = dis[t] + e[i].w;
                if(!in[to])
                {
                    q.push(to);
                    in[to] = 1;
                }
            }
        }
    }
}
```
